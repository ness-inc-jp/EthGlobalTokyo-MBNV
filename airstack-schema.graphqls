directive @binding(constraint: String!, errorCode: String!) on INPUT_FIELD_DEFINITION | ARGUMENT_DEFINITION

directive @db(collectionFieldName: String!, startPrefix: String, endPrefix: String, isStartExclusive: String, isEndExclusive: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

"""
The @specifiedBy built-in directive is used within the type system definition
language to provide a scalar specification URL for specifying the behavior of
custom scalar types.
"""
directive @specifiedBy(url: String!) on SCALAR

scalar Address

input Address_Comparator_Exp {
  _eq: Address
  _ne: Address
  _in: [Address!]
  _nin: [Address!]
}

type AnimationUrlVariants {
  original: String
}

enum Blockchain {
  ethereum
}

input Boolean_Comparator_Exp {
  _eq: Boolean
}

type CollectionStat {
  """  Airstack unique identifier for the data point """
  id: ID!

  """ Airstack unique identifier for the blockchain """
  chainId: String

  """ NFT contract address on the blockchain """
  tokenAddress: Address!

  """ Blockchain where the NFT contract is deployed """
  blockchain: Blockchain

  """ Marketplace DApp name where the collection stats are taken from """
  dappName: MarketplaceDappName

  """ Marketplace DApp slug (contract version) where the collection stats are taken from 
  """
  dappSlug: MarketplaceDappSlug
  dappVersion: String
  firstTransactionBlockTimestamp: Time
  lastTransactionBlockTimestamp: Time
  totalSalesCount: Int
  averageSalePriceInUSDC: Float
  averageSalePriceInNativeToken: Float
  lowestSalePriceInUSDC: Float
  lowestSalePriceInNativeToken: Float
  lowestSaleTransactionId: String
  highestSalePriceInUSDC: Float
  highestSalePriceInNativeToken: Float
  highestSaleTransactionId: String
  totalFeeVolumeInUSDC: Float
  totalFeeVolumeInNativeToken: Float
  totalRoyaltyFeeVolumeInUSDC: Float
  totalRoyaltyFeeVolumeInNativeToken: Float
  totalSaleVolumeInUSDC: Float
  totalSaleVolumeInNativeToken: Float
  timeFrame: TimeFrames
  token: Token
}

input CollectionStatFilter {
  _and: [CollectionStatFilter!]
  _or: [CollectionStatFilter!]
  _nor: [CollectionStatFilter!]
  tokenAddress: Address_Comparator_Exp
  dappName: MarketplaceDappName_Comparator_Exp
  dappSlug: MarketplaceDappSlug_Comparator_Exp
  firstTransactionBlockTimestamp: Time_Comparator_Exp
  lastTransactionBlockTimestamp: Time_Comparator_Exp
  totalSalesCount: Int_Comparator_Exp
  averageSalePriceInUSDC: Float_Comparator_Exp
  lowestSalePriceInUSDC: Float_Comparator_Exp
  highestSalePriceInUSDC: Float_Comparator_Exp
  totalSaleVolumeInUSDC: Float_Comparator_Exp
}

input CollectionStatOrderBy {
  firstTransactionBlockTimestamp: OrderBy
  lastTransactionBlockTimestamp: OrderBy
  totalSalesCount: OrderBy
  averageSalePriceInUSDC: OrderBy
  lowestSalePriceInUSDC: OrderBy
  highestSalePriceInUSDC: OrderBy
  totalSaleVolumeInUSDC: OrderBy
}

input CollectionStatsInput {
  order: [CollectionStatOrderBy!]
  filter: CollectionStatFilter!
  blockchain: Blockchain!
  timeFrame: TimeFrames!
  limit: Int
  cursor: String
}

type CollectionStatsOutput {
  CollectionStat: [CollectionStat!]
  pageInfo: PageInfo
}

type ContractMetadata {
  """ Name of the token, mirrored from the smart contract """
  name: String

  """ Description of the token, mirrored from the smart contract """
  description: String
  image: String
  externalLink: String
  sellerFeeBasisPoints: Int

  """ Royalties recipient address, mirrored from the smart contract """
  feeRecipient: String
}

input Date_Range_Comparator_Exp {
  _eq: String
}

scalar DateRange

type Domain {
  """  Airstack unique identifier for the data point """
  id: ID

  """ Parent domain name, if the entity is a subdomain """
  parent: String

  """
   Nested query - domain owner related information, including address, domains,
  social profile, other token balances, and transfer history 
  """
  owner: Address!

  """ Blockchain address to which the domain is resolved """
  resolvedAddress: Address

  """ Timestamp when the domain registration expires """
  expiryTimestamp: Time

  """ Indicates if the domain is set to be primary - true or false """
  isPrimary: Boolean

  """ Domain name without the domain ending, e.g. vitalik instead of vitalik.eth 
  """
  labelName: String

  """ Airstack unique domain hash """
  labelHash: String

  """ Full domain name, e.g. vitalik.eth """
  name: String

  """ Nested query - can retrieve payment token data (name, symbol, etc.) """
  paymentToken: Token

  """ payment amount in blockchain native token for the domain """
  paymentTokenCostInNativeToken: Float

  """ payment amount in USDC for the domain """
  paymentTokenCostInUSDC: Float

  """ Domain registration cost """
  registrationCost: String

  """ Domain registration cost in blockchain native token """
  registrationCostInNativeToken: String

  """ Domain registration cost in USDC """
  registrationCostInUSDC: String

  """ Domain registration cost in decimals """
  formattedRegistrationCost: Float

  """ Domain registration cost in native blockchain token in decimals """
  formattedRegistrationCostInNativeToken: Float

  """ Domain registration cost in USDC in decimals """
  formattedRegistrationCostInUSDC: Float

  """ Nested query allowing to retrieve subdomain information associated with the domain
  """
  subDomains: [Domain]

  """ Count of subdomains linked to the domain """
  subDomainCount: Int

  """ Domain Token ID associated with the domain, if applicable """
  tokenId: String

  """ Time-to-live value for the domain """
  ttl: String

  """ Airstack unique identifier for the blockchain """
  chainId: String

  """ Blockchain where the NFT sale took place """
  blockchain: Blockchain!

  """ DApp name associated with the domain (e.g. ENS) """
  dappName: DomainDappName

  """ DApp slug (contract version) associated with the domain """
  dappSlug: DomainDappSlug

  """ Block number when the domain was created """
  createdAtBlockNumber: Int

  """ Timestamp when the domain was created """
  createdAtBlockTimestamp: Time

  """ Block number when the domain was last updated """
  lastUpdatedBlockNumber: Int

  """ Timestamp when the domain was last updated """
  lastUpdatedBlockTimestamp: Time
}

enum DomainDappName {
  ens
}

input DomainDappName_Comparator_Exp {
  _eq: DomainDappName
  _in: [DomainDappName!]
}

enum DomainDappSlug {
  ens_v1
}

input DomainDappSlug_Comparator_Exp {
  _eq: DomainDappSlug
  _in: [DomainDappSlug!]
}

input DomainFilter {
  _and: [DomainFilter!]
  _or: [DomainFilter!]
  _nor: [DomainFilter!]
  parent: String_Comparator_Exp
  owner: Identity_Comparator_Exp
  resolvedAddress: Address_Comparator_Exp
  isPrimary: Boolean_Comparator_Exp
  name: String_Comparator_Exp
}

input DomainInput {
  resolvedAddress: Address
  name: String
  blockchain: Blockchain!
}

input DomainOrderBy {
  expiryTimestamp: OrderBy
  createdAtBlockTimestamp: OrderBy
  lastUpdatedBlockTimestamp: OrderBy
}

input DomainsInput {
  order: [DomainOrderBy!]
  filter: DomainFilter!
  blockchain: Blockchain!
  limit: Int
  cursor: String
}

type DomainsOutput {
  Domain: [Domain!]
  pageInfo: PageInfo
}

input Float_Comparator_Exp {
  _eq: Float
  _gt: Float
  _gte: Float
  _lt: Float
  _lte: Float
  _ne: Float
  _in: [Float!]
  _nin: [Float!]
}

type HistoricalBalance {
  owner: Address!
  tokenAddress: String!
  amount: String
  formattedAmount: Float
  tokenType: String
  blockchain: Blockchain
  date: DateRange
  timestamp: TimeRange
  blockNumber: Range
  tokenNft: TokenNft
  token: Token
  chainId: String
  tokenId: String
}

input HistoricalBalanceFilter {
  _and: [HistoricalBalanceFilter!]
  _or: [HistoricalBalanceFilter!]
  _nor: [HistoricalBalanceFilter!]
  owner: Address_Comparator_Exp
  tokenAddress: String_Comparator_Exp
  tokenType: String_Comparator_Exp
  date: Date_Range_Comparator_Exp
  timestamp: Time_Range_Comparator_Exp
  blockNumber: Range_Comparator_Exp
}

input HistoricalBalanceOrderBy {
  owner: OrderBy
  tokenAddress: OrderBy
}

input HistoricalBalancesInput {
  order: [HistoricalBalanceOrderBy!]
  filter: HistoricalBalanceFilter!
  blockchain: Blockchain!
  limit: Int
  cursor: String
}

type HistoricalBalancesOutput {
  HistoricalBalance: [HistoricalBalance!]
  pageInfo: PageInfo
}

scalar Identity

input Identity_Comparator_Exp {
  _eq: Identity
  _in: [Identity!]
}

type ImageSizes {
  extraSmall: String
  small: String
  medium: String
  large: String
  original: String
}

input Int_Comparator_Exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _lt: Int
  _lte: Int
  _ne: Int
  _in: [Int!]
  _nin: [Int!]
}

input Int_String_Comparator_Exp {
  _eq: String
  _gt: String
  _gte: String
  _lt: String
  _lte: String
  _ne: String
  _in: [String!]
  _nin: [String!]
}

scalar IntString

type LogoSizes {
  small: String
  medium: String
  large: String
  original: String
  external: String
}

scalar Map

enum MarketplaceDappName {
  rarible
  opensea
}

input MarketplaceDappName_Comparator_Exp {
  _eq: MarketplaceDappName
  _in: [MarketplaceDappName!]
}

enum MarketplaceDappSlug {
  rarible_exchange_v1
  rarible_exchange_v2
  opensea_seaport
  opensea_wyvern_exchange
}

input MarketplaceDappSlug_Comparator_Exp {
  _eq: MarketplaceDappSlug
  _in: [MarketplaceDappSlug!]
}

type MarketplaceStat {
  """  Airstack unique identifier for the data point """
  id: ID!

  """ Airstack unique identifier for the blockchain """
  chainId: String

  """ Blockchain where the marketplace data is calculated from """
  blockchain: Blockchain
  dappName: MarketplaceDappName
  dappSlug: MarketplaceDappSlug!
  dappVersion: String
  firstTransactionBlockTimestamp: Time
  lastTransactionBlockTimestamp: Time
  totalSalesCount: Int
  averageSalePriceInUSDC: Float
  averageSalePriceInNativeToken: Float
  lowestSalePriceInUSDC: Float
  lowestSalePriceInNativeToken: Float
  lowestSaleTransactionId: String
  highestSalePriceInUSDC: Float
  highestSalePriceInNativeToken: Float
  highestSaleTransactionId: String
  totalFeeVolumeInUSDC: Float
  totalFeeVolumeInNativeToken: Float
  totalRoyaltyFeeVolumeInUSDC: Float
  totalRoyaltyFeeVolumeInNativeToken: Float
  totalSaleVolumeInUSDC: Float
  totalSaleVolumeInNativeToken: Float
  timeFrame: TimeFrames
}

input MarketplaceStatFilter {
  _and: [MarketplaceStatFilter!]
  _or: [MarketplaceStatFilter!]
  _nor: [MarketplaceStatFilter!]
  dappName: MarketplaceDappName_Comparator_Exp
  dappSlug: MarketplaceDappSlug_Comparator_Exp
  firstTransactionBlockTimestamp: Time_Comparator_Exp
  lastTransactionBlockTimestamp: Time_Comparator_Exp
  totalSalesCount: Int_Comparator_Exp
  averageSalePriceInUSDC: Float_Comparator_Exp
  lowestSalePriceInUSDC: Float_Comparator_Exp
  highestSalePriceInUSDC: Float_Comparator_Exp
  totalSaleVolumeInUSDC: Float_Comparator_Exp
}

input MarketplaceStatOrderBy {
  firstTransactionBlockTimestamp: OrderBy
  lastTransactionBlockTimestamp: OrderBy
  totalSalesCount: OrderBy
  averageSalePriceInUSDC: OrderBy
  lowestSalePriceInUSDC: OrderBy
  highestSalePriceInUSDC: OrderBy
  totalSaleVolumeInUSDC: OrderBy
}

input MarketplaceStatsInput {
  order: [MarketplaceStatOrderBy!]
  filter: MarketplaceStatFilter!
  blockchain: Blockchain!
  timeFrame: TimeFrames!
  limit: Int
  cursor: String
}

type MarketplaceStatsOutput {
  MarketplaceStat: [MarketplaceStat!]
  pageInfo: PageInfo
}

type Media {
  image: ImageSizes
  video: String
  audio: String
  animation_url: AnimationUrlVariants
}

type Nft {
  """ Smart contract address of the NFT token which was sold """
  tokenAddress: Address!

  """ Unique NFT token ID or IDs (if ERC1155) in the sale transaction """
  tokenId: String!

  """ Number of NFT tokens in the sale transaction """
  tokenAmount: String

  """ Type of NFT - ERC721 or ERC1155 """
  tokenType: TokenType

  """
   Nested Query - allows retrieving token Token NFT level data, such as images,
  traits, and so on for each unique NFT in the transfer
  """
  tokenNft: TokenNft

  """ Nested Query - allows retrieving token contract level data """
  token: Token
}

type NftAttribute {
  """ NFT attribute type as defined in the smart contract, e.g. background """
  trait_type: String

  """ NFT attribute value as defined in the smart contract, e.g. blue """
  value: String
  displayType: String
  maxValue: String
}

input NftAttributeFilter {
  _and: [NftAttributeFilter!]
  _or: [NftAttributeFilter!]
  _nor: [NftAttributeFilter!]
  trait_type: String_Comparator_Exp
  value: String_Comparator_Exp
}

input NftAttributesInput {
  filter: NftAttributeFilter!
  limit: Int
  cursor: String
}

type NftAttributesOutput {
  NftAttribute: [NftAttribute!]
  pageInfo: PageInfo
}

input NftFilter {
  _and: [NftFilter!]
  _or: [NftFilter!]
  _nor: [NftFilter!]
  tokenAddress: Address_Comparator_Exp
  tokenId: String_Comparator_Exp
}

input NftInput {
  tokenAddress: Address!
  tokenId: String!
}

type NftMetadata {
  """ Name of the token, mirrored from the smart contract """
  name: String

  """ Description of the token, mirrored from the smart contract """
  description: String

  """ Link to the token image, mirrored from the smart contract """
  image: String
  attributes: [NftAttribute!]
  imageData: String
  backgroundColor: String
  youtubeUrl: String
  externalUrl: String
  animationUrl: String
}

input NftMetadataFilter {
  _and: [NftMetadataFilter!]
  _or: [NftMetadataFilter!]
  _nor: [NftMetadataFilter!]
  name: String_Comparator_Exp
  attributes: NftAttributeFilter
}

input NftMetadataOrderBy {
  attributes: OrderBy
}

input NftMetadatasInput {
  order: [NftMetadataOrderBy!]
  filter: NftMetadataFilter!
  limit: Int
  cursor: String
}

type NftMetadatasOutput {
  NftMetadata: [NftMetadata!]
  pageInfo: PageInfo
}

type NFTSaleTransaction {
  """  Airstack unique identifier for the data point """
  id: ID

  """ Airstack unique identifier for the blockchain """
  chainId: String

  """ Blockchain where the NFT sale took place """
  blockchain: Blockchain

  """ Block number of the NFT sale transaction """
  blockNumber: Int

  """ Marketplace DApp name where the transaction took place """
  dappName: MarketplaceDappName

  """ Marketplace DApp slug (contract version) name where the transaction took place 
  """
  dappSlug: MarketplaceDappSlug

  """ Airstack unique dappVersion number """
  dappVersion: String

  """ Fee amount for the NFT sale transaction """
  feeAmount: String

  """ Fee amount in blockchain native token for the NFT sale transaction """
  feeAmountInNativeToken: String

  """ Fee amount in USDC for the NFT sale transaction """
  feeAmountInUSDC: String

  """
   Nested query - fee beneficiary wallet related information, including address,
  domains, social profile, other token balances, and transfer history 
  """
  feeBeneficiary: Wallet

  """ Formatted fee amount in decimals for the NFT sale transaction """
  formattedFeeAmount: Float

  """ Formatted fee amount in decimals in blockchain native token for the NFT sale transaction 
  """
  formattedFeeAmountInNativeToken: Float

  """ Formatted fee amount in decimals USDC for the NFT sale transaction """
  formattedFeeAmountInUSDC: Float

  """ Formatted payment amount in decimals for the NFT sale transaction """
  formattedPaymentAmount: Float

  """ Formatted payment amount in decimals in blockchain native token for the NFT sale transaction 
  """
  formattedPaymentAmountInNativeToken: Float

  """ Formatted payment amount in decimals USDC for the NFT sale transaction 
  """
  formattedPaymentAmountInUSDC: Float

  """
   Nested query - seller wallet related information, including address, domains,
  social profile, other token balances, and transfer history 
  """
  from: Wallet

  """ Payment amount for the NFT sale transaction """
  paymentAmount: String

  """ Payment amount for the NFT sale transaction in blockchain native token 
  """
  paymentAmountInNativeToken: String

  """ Payment amount for the NFT sale transaction in USDC """
  paymentAmountInUSDC: String

  """ Nested query - payment token contract level information, such as token name, symbol, and other token metadata 
  """
  paymentToken: Token

  """ Payment token price/value in blockchain native token """
  paymentTokenPriceInNativeToken: Float

  """ Payment token price/value in USDC """
  paymentTokenPriceInUSDC: Float

  """
   Nested Query - returns token contract address, amount in the sale transaction,
  unique NFT token ID, NFT contract metadata, and NFT token metadata, including images 
  """
  nfts: [Nft!]
  saleType: SaleType

  """ NFT token sale transction hash """
  transactionHash: String

  """
   Nested query - buyer wallet related information, including address, domains,
  social profile, other token balances, and transfer history 
  """
  to: Wallet

  """ NFT token sale block timestamp """
  blockTimestamp: Time

  """ NFT token sale transaction type """
  transactionType: String

  """
  Nested query - NFT sale royalties related information, such as amount, beneficiary address 
  """
  royalties: [Royalty!]
}

input NFTSaleTransactionFilter {
  _and: [NFTSaleTransactionFilter!]
  _or: [NFTSaleTransactionFilter!]
  _nor: [NFTSaleTransactionFilter!]
  dappName: MarketplaceDappName_Comparator_Exp
  dappSlug: MarketplaceDappSlug_Comparator_Exp
  from: Address_Comparator_Exp
  nfts: NftFilter
  transactionHash: String_Comparator_Exp
  to: Address_Comparator_Exp
  blockTimestamp: Time_Comparator_Exp
}

input NFTSaleTransactionOrderBy {
  blockTimestamp: OrderBy
}

input NFTSaleTransactionsInput {
  order: [NFTSaleTransactionOrderBy!]
  filter: NFTSaleTransactionFilter!
  blockchain: Blockchain!
  limit: Int
  cursor: String
}

type NFTSaleTransactionsOutput {
  NFTSaleTransaction: [NFTSaleTransaction!]
  pageInfo: PageInfo
}

input NftsInput {
  filter: NftFilter!
  limit: Int
  cursor: String
}

type NftsOutput {
  Nft: [Nft!]
  pageInfo: PageInfo
}

type NFTStat {
  """  Airstack unique identifier for the data point """
  id: ID!

  """ Airstack unique identifier for the blockchain """
  chainId: String

  """ NFT contract address on the blockchain """
  tokenAddress: Address!

  """ Unique NFT token ID """
  tokenId: String

  """ Blockchain where the NFT contract is deployed """
  blockchain: Blockchain

  """ Marketplace DApp name where the NFT token stats are taken from """
  dappName: MarketplaceDappName

  """ Marketplace DApp slug (contract version) where the NFT token stats are taken from 
  """
  dappSlug: MarketplaceDappSlug
  dappVersion: String
  firstTransactionBlockTimestamp: Time
  lastTransactionBlockTimestamp: Time
  totalSalesCount: Int
  averageSalePriceInUSDC: Float
  averageSalePriceInNativeToken: Float
  lowestSalePriceInUSDC: Float
  lowestSalePriceInNativeToken: Float
  lowestSaleTransactionId: String
  highestSalePriceInUSDC: Float
  highestSalePriceInNativeToken: Float
  highestSaleTransactionId: String
  totalFeeVolumeInUSDC: Float
  totalFeeVolumeInNativeToken: Float
  totalRoyaltyFeeVolumeInUSDC: Float
  totalRoyaltyFeeVolumeInNativeToken: Float
  totalSaleVolumeInUSDC: Float
  totalSaleVolumeInNativeToken: Float
  timeFrame: TimeFrames
  tokenNft: TokenNft
}

input NFTStatFilter {
  _and: [NFTStatFilter!]
  _or: [NFTStatFilter!]
  _nor: [NFTStatFilter!]
  tokenAddress: Address_Comparator_Exp
  tokenId: String_Comparator_Exp
  dappName: MarketplaceDappName_Comparator_Exp
  dappSlug: MarketplaceDappSlug_Comparator_Exp
  firstTransactionBlockTimestamp: Time_Comparator_Exp
  lastTransactionBlockTimestamp: Time_Comparator_Exp
  totalSalesCount: Int_Comparator_Exp
  averageSalePriceInUSDC: Float_Comparator_Exp
  lowestSalePriceInUSDC: Float_Comparator_Exp
  highestSalePriceInUSDC: Float_Comparator_Exp
  totalSaleVolumeInUSDC: Float_Comparator_Exp
}

input NFTStatOrderBy {
  firstTransactionBlockTimestamp: OrderBy
  lastTransactionBlockTimestamp: OrderBy
  totalSalesCount: OrderBy
  averageSalePriceInUSDC: OrderBy
  lowestSalePriceInUSDC: OrderBy
  highestSalePriceInUSDC: OrderBy
  totalSaleVolumeInUSDC: OrderBy
}

input NFTStatsInput {
  order: [NFTStatOrderBy!]
  filter: NFTStatFilter!
  blockchain: Blockchain!
  timeFrame: TimeFrames!
  limit: Int
  cursor: String
}

type NFTStatsOutput {
  NFTStat: [NFTStat!]
  pageInfo: PageInfo
}

enum OrderBy {
  ASC
  DESC
}

enum OrderByAsIntString {
  ASC
  DESC
}

type PageInfo {
  prevCursor: String!
  nextCursor: String!
}

type ProjectDetails {
  collectionName: String
  description: String
  externalUrl: String
  twitterUrl: String
  discordUrl: String
}

type Query {
  Token(input: TokenInput!): Token
  Tokens(input: TokensInput!): TokensOutput
  TokenNft(input: TokenNftInput!): TokenNft
  TokenNfts(input: TokenNftsInput!): TokenNftsOutput
  TokenBalance(input: TokenBalanceInput!): TokenBalance
  TokenBalances(input: TokenBalancesInput!): TokenBalancesOutput
  TokenTransfer(input: TokenTransferInput!): TokenTransfer
  TokenTransfers(input: TokenTransfersInput!): TokenTransfersOutput
  NFTSaleTransactions(input: NFTSaleTransactionsInput!): NFTSaleTransactionsOutput
  Domain(input: DomainInput!): Domain
  Domains(input: DomainsInput!): DomainsOutput
  CollectionStats(input: CollectionStatsInput!): CollectionStatsOutput
  NFTStats(input: NFTStatsInput!): NFTStatsOutput
  MarketplaceStats(input: MarketplaceStatsInput!): MarketplaceStatsOutput
  Wallet(input: WalletInput!): Wallet
  Socials(input: SocialsInput!): SocialsOutput
}

scalar Range

input Range_Comparator_Exp {
  _eq: Int
}

type Royalty {
  beneficiaryAddress: String
  amount: String
  formattedAmount: Float
  amountInUSDC: String
  formattedAmountInUSDC: Float
  amountInNativeToken: String
  formattedAmountInNativeToken: Float
}

enum SaleType {
  SINGLE_ITEM_SALE
  BUNDLE_SALE
}

type Social {
  """  Airstack unique identifier for the data point """
  id: ID

  """ Airstack unique identifier for the blockchain """
  chainId: String

  """Blockchain associated with the social identity"""
  blockchain: Blockchain

  """ Social DApp name """
  dappName: SocialDappName

  """ Social DApp slug (contract version) """
  dappSlug: SocialDappSlug

  """ Airstack unique dapp version number """
  dappVersion: String
  userId: String
  userAddress: Address
  userCreatedAtBlockTimestamp: Time
  userCreatedAtBlockNumber: Int
  userLastUpdatedAtBlockTimestamp: Time
  userLastUpdatedAtBlockNumber: Int
  userHomeURL: String
  userRecoveryAddress: Address

  """ blockchain addresses associated with the social profile """
  userAssociatedAddresses: [Address!]
  profileName: String
  profileTokenId: String
  profileTokenAddress: String
  profileCreatedAtBlockTimestamp: Time
  profileCreatedAtBlockNumber: Int
  profileLastUpdatedAtBlockTimestamp: Time
  profileLastUpdatedAtBlockNumber: Int
  profileTokenUri: String
}

enum SocialDappName {
  farcaster
}

input SocialDappName_Comparator_Exp {
  _eq: SocialDappName
  _in: [SocialDappName!]
}

enum SocialDappSlug {
  farcaster_goerli
}

input SocialDappSlug_Comparator_Exp {
  _eq: SocialDappSlug
  _in: [SocialDappSlug!]
}

input SocialFilter {
  _and: [SocialFilter!]
  _or: [SocialFilter!]
  _nor: [SocialFilter!]
  dappName: SocialDappName_Comparator_Exp
  dappSlug: SocialDappSlug_Comparator_Exp
  userId: String_Comparator_Exp
  userAssociatedAddresses: Address_Comparator_Exp
  profileName: String_Comparator_Exp
}

input SocialsInput {
  filter: SocialFilter!
  blockchain: Blockchain!
  limit: Int
  cursor: String
}

type SocialsOutput {
  Social: [Social!]
  pageInfo: PageInfo
}

input String_Comparator_Exp {
  _eq: String
  _gt: String
  _gte: String
  _lt: String
  _lte: String
  _ne: String
  _in: [String!]
  _nin: [String!]
}

scalar Time

input Time_Comparator_Exp {
  _eq: Time
  _gt: Time
  _gte: Time
  _lt: Time
  _lte: Time
  _ne: Time
  _in: [Time!]
  _nin: [Time!]
}

input Time_Range_Comparator_Exp {
  _eq: Int
}

enum TimeFrames {
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
  LIFETIME
}

scalar TimeRange

type Token {
  """ Airstack unique identifier for the contract """
  id: ID

  """ Smart contract address of the token """
  address: Address!

  """Airstack unique identifier for the blockchain"""
  chainId: String

  """Blockchain where the token smart contract is deployed"""
  blockchain: TokenBlockchain

  """ Name of the token, mirrored from the smart contract """
  name: String

  """ Symbol of the token, mirrored from the smart contract """
  symbol: String

  """ Token type: ERC20, ERC721, or ERC1155 """
  type: TokenType

  """ Amount of tokens in the protocol """
  totalSupply: String

  """ The number of decimal places this token uses, default to 18 """
  decimals: Int

  """ Logo image for the contract in various sizes (if available) """
  logo: LogoSizes

  """ URI for the token's contract metadata """
  contractMetaDataURI: String

  """ Token contract metadata object """
  contractMetaData: ContractMetadata

  """ Token contract metadata as it appears inside the contract """
  rawContractMetaData: Map

  """ Base URI of the token contract """
  baseURI: String

  """ Timestamp of the token's most recent transfer """
  lastTransferTimestamp: Time

  """ Block number of the token's most recent transfer """
  lastTransferBlock: Int

  """ Transaction hash of the token's most recent transfer """
  lastTransferHash: String

  """ Returns count of all NFT token attribute types and values for the given smart contract 
  """
  tokenTraits: Map

  """ Nested Query - allows querying the tokenBalance information """
  tokenBalances: [TokenBalance!]

  """ Nested Query - allows querying the tokenNFTs information """
  tokenNfts: [TokenNft!]

  """ off-chain data for the token project """
  projectDetails: ProjectDetails
}

type TokenBalance {
  """  Airstack unique identifier for the data point """
  id: ID!

  """ Airstack unique identifier for the blockchain """
  chainId: String!

  """ Blockchain where the token smart contract is deployed """
  blockchain: TokenBlockchain

  """ Smart contract address of the token """
  tokenAddress: Address!

  """ Unique NFT token ID """
  tokenId: String

  """ Nested Query allowing to retrieve address, domain names, social profiles of the owner
  """
  owner: Wallet!

  """ Token amount the address currently holds"""
  amount: String!

  """ Formatted token balance in decimals """
  formattedAmount: Float

  """ Block number of the latest token balance change happened """
  lastUpdatedBlock: Int!

  """ Timestamp of the latest token balance change happened """
  lastUpdatedTimestamp: Time

  """ Token type: ERC20, ERC721, or ERC1155 """
  tokenType: TokenType

  """ Nested Query - allows retrieving token contract level data """
  token: Token

  """ Nested Query - allows retrieving token NFT contract level data, such as images, traits, and so on 
  """
  tokenNfts: TokenNft

  """ Nested Query - allows retrieving token transfer history """
  tokenTransfers: [TokenTransfer!]
}

input TokenBalanceFilter {
  _and: [TokenBalanceFilter!]
  _or: [TokenBalanceFilter!]
  _nor: [TokenBalanceFilter!]
  tokenAddress: Address_Comparator_Exp
  tokenId: String_Comparator_Exp
  owner: Identity_Comparator_Exp
  formattedAmount: Float_Comparator_Exp
  tokenType: TokenType_Comparator_Exp
}

input TokenBalanceInput {
  blockchain: TokenBlockchain!
  tokenAddress: Address!
  tokenId: String
  owner: Identity
}

input TokenBalanceOrderBy {
  lastUpdatedTimestamp: OrderBy
}

input TokenBalancesInput {
  order: [TokenBalanceOrderBy!]
  filter: TokenBalanceFilter!
  blockchain: TokenBlockchain!
  limit: Int
  cursor: String
}

type TokenBalancesOutput {
  TokenBalance: [TokenBalance!]
  pageInfo: PageInfo
}

enum TokenBlockchain {
  ethereum
  polygon
}

input TokenFilter {
  _and: [TokenFilter!]
  _or: [TokenFilter!]
  _nor: [TokenFilter!]
  address: Address_Comparator_Exp
  name: String_Comparator_Exp
  symbol: String_Comparator_Exp
  type: TokenType_Comparator_Exp
}

input TokenInput {
  address: Address!
  blockchain: TokenBlockchain!
}

type TokenNft {
  """ Airstack unique identifier for the NFT token """
  id: ID!

  """ Smart contract address of the token """
  address: Address!

  """ Unique NFT token ID """
  tokenId: String!

  """ Blockchain where the token smart contract is deployed """
  blockchain: TokenBlockchain

  """ Airstack unique identifier for the blockchain """
  chainId: String!

  """ NFT Token type: ERC721, or ERC1155 """
  type: TokenType

  """ Amount of NFT tokens in the protocol """
  totalSupply: String

  """ NFT token URI """
  tokenURI: String

  """ Content type of the NFT token (image, video, audio, etc.) """
  contentType: String

  """ NFT Media - resized images, animation, videos, etc. """
  contentValue: Media

  """ NFT token metadata and attributes"""
  metaData: NftMetadata

  """ NFT token metadata, mirrored from the smart contract"""
  rawMetaData: Map

  """ Transaction hash of the NFT token most recent transfer """
  lastTransferHash: String

  """ Block number of the NFT token most recent transfer """
  lastTransferBlock: Int

  """ Timestamp of the NFT token most recent transfer """
  lastTransferTimestamp: Time

  """ Nested Query - allows retrieving token contract level data """
  token: Token

  """ Nested Query - allows querying the tokenBalance information """
  tokenBalances: [TokenBalance!]

  """ Nested Query - allows querying the nftSaleTransactions information """
  nftSaleTransactions: [NFTSaleTransaction!]

  """ Nested Query - allows querying the tokenTransfer information """
  tokenTransfers: [TokenTransfer!]
}

input TokenNftFilter {
  _and: [TokenNftFilter!]
  _or: [TokenNftFilter!]
  _nor: [TokenNftFilter!]
  address: Address_Comparator_Exp
  tokenId: String_Comparator_Exp
  metaData: NftMetadataFilter
}

input TokenNftInput {
  address: Address!
  tokenId: String!
  blockchain: TokenBlockchain!
}

input TokenNftOrderBy {
  tokenId: OrderBy
}

input TokenNftsInput {
  order: [TokenNftOrderBy!]
  filter: TokenNftFilter!
  blockchain: TokenBlockchain!
  limit: Int
  cursor: String
}

type TokenNftsOutput {
  TokenNft: [TokenNft!]
  pageInfo: PageInfo
}

input TokenOrderBy {
  name: OrderBy
  symbol: OrderBy
  type: OrderBy
}

input TokensInput {
  order: [TokenOrderBy!]
  filter: TokenFilter!
  blockchain: TokenBlockchain!
  limit: Int
  cursor: String
}

type TokensOutput {
  Token: [Token!]
  pageInfo: PageInfo
}

type TokenTransfer {
  """  Airstack unique identifier for the data point """
  id: ID

  """ Airstack unique identifier for the blockchain """
  chainId: String

  """ Blockchain where the token transfer took place """
  blockchain: TokenBlockchain

  """
   Nested query - sender wallet related information, including address, domains,
  social profile, other token balances, and transfer history 
  """
  from: Wallet

  """
   Nested query - recipient wallet related information, including address,
  domains, social profile, other token balances, and transfer history 
  """
  to: Wallet

  """ Type of the token transfer """
  type: String

  """ Transferred token smart contract address """
  tokenAddress: Address

  """
   Nested query - operator wallet (if the transaction was facilitated via smart
  contract) related information, including address, domains, social profile,
  other token balances, and transfer history 
  """
  operator: Wallet

  """ Token amount in the transfer """
  amount: String

  """ Formatted transfer amount in decimals """
  formattedAmount: Float

  """ Unique NFT token ID """
  tokenId: String

  """ Token amounts in the transfer, if applicable. This mostly occurs in ERC1155 batch transfers 
  """
  amounts: [String!]

  """ Unique NFT token IDs if multiple NFTs were a part of the transfer """
  tokenIds: [String!]

  """ Token type: ERC20, ERC721, or ERC1155 """
  tokenType: TokenType

  """ Token transfer transction hash """
  transactionHash: String!

  """Block timestamp of the token transfer"""
  blockTimestamp: Time

  """Block number of the token transfer"""
  blockNumber: Int

  """
   Nested Query - allows retrieving token Token NFT level data, such as images,
  traits, and so on for each unique NFT in the transfer
  """
  tokenNft: TokenNft

  """ Nested Query - allows retrieving token contract level data """
  token: Token
}

input TokenTransferFilter {
  _and: [TokenTransferFilter!]
  _or: [TokenTransferFilter!]
  _nor: [TokenTransferFilter!]
  from: Identity_Comparator_Exp
  to: Identity_Comparator_Exp
  tokenAddress: Address_Comparator_Exp
  formattedAmount: Float_Comparator_Exp
  tokenId: String_Comparator_Exp
  tokenType: TokenType_Comparator_Exp
  transactionHash: String_Comparator_Exp
  blockTimestamp: Time_Comparator_Exp
}

input TokenTransferInput {
  blockchain: TokenBlockchain!
  transactionHash: String!
}

input TokenTransferOrderBy {
  blockTimestamp: OrderBy
}

input TokenTransfersInput {
  order: [TokenTransferOrderBy!]
  filter: TokenTransferFilter!
  blockchain: TokenBlockchain!
  limit: Int
  cursor: String
}

type TokenTransfersOutput {
  TokenTransfer: [TokenTransfer!]
  pageInfo: PageInfo
}

enum TokenType {
  ERC1155
  ERC721
  ERC20
}

input TokenType_Comparator_Exp {
  _eq: TokenType
  _in: [TokenType!]
}

type Wallet {
  """
   Blockchain address, domain name, social identity (for Farcaster use 'fc_fid:'
  prefix followed by the Farcaster user ID like fc_fid:5650, or use 'fc_fname:'
  prefix followed by the Farcaster user ID like 'fc_fname:vbuterin') 
  """
  identity: Identity!

  """Blockchain associated with the provided identity"""
  blockchain: TokenBlockchain

  """ Returns addresses associated with the identity input """
  addresses: [Address!]

  """ Nested query - allows returning primary domains, if applicable """
  primaryDomain: Domain

  """ Nested query - allows querying domains owned by the address """
  domains: [Domain!]

  """ Returns social profile information related to the address """
  socials: [Social!]

  """ Nested query - allows returning token transfers and related information 
  """
  tokenTransfers: [TokenTransfer!]

  """ Nested query - allows returning token balances """
  tokenBalances: [TokenBalance!]

  """ Nested query - allows querying NFT Sales completed by the wallet """
  nftSaleTransactions: [NFTSaleTransaction!]
}

input WalletInput {
  identity: Identity!
  blockchain: TokenBlockchain!
}

